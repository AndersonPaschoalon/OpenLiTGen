// parametro de entrada: tempo de geração maximo - caso não seja especificado, usar default
// deve haver uma packet queue composta de pacotes 
// carregar o modelo especificado, gerar as distribuições e listas correspondentes a esse modelo
// para cada usuario, utilizando o modelo, gerar pacotes até que o tempo seja maior ou igual ao 
//      ao tempo maximo especificado
// a lista gerada para todos os usuarios devera ser mergeada. 
// Utilizando um gerador de trafego (Tins, csv), ele devera receber um a um os pacotes modelados,
//      e enviar ao destino especificado.

#include <iostream>
#include <string>
#include <getopt.h>
#include "LitModel.h"
#include "Timer.h"
#include "TgEngine.h"
#include "TgCsv.h"
#include "TgConsole.h"
#include "TgPcap.h"
#include "TgTins.h"



#define LITGEN_TG_VERSION "1.0"

const char helpMenu[] = R"(
Usage: litgen-tg [OPTIONS]

Options:
  --max-time <max-time-seconds>    (optional) Maximum time in seconds for the traffic to be generated. Default is 3600 seconds.
  -m, --model <lit-model>          LitGen model to be loaded and used.
  -i, --interface <dst-net-interface> Specify the network interface, file type (.csv, .pcap), or 'console' for output:
                                     - Supported interface names: eth0, eth1, wlan0, console, stdout
                                     - If .csv, generates a CSV file immediately.
                                     - If .pcap, generates a PCAP file immediately.
                                     - If 'console' or 'stdout', prints packets to console in real time.
                                     - Otherwise, assumes it is a network interface and attempts to send packets.

  -v, --version                    Show version information and exit.
  -h, --help                       Show this help message and exit.

Description:
  litgen-tg is the traffic generator component of LitGen. It takes a model generated by litgen-model (.lit file) as input and generates traffic based on the LitGen model architecture.

Examples:
  litgen-tg --max-time 1800 -m model.lit -i eth1

  litgen-tg -m model.lit --interface wlan0

  litgen-tg -h

)";

void displayHelp();
void displayVersion();
bool litgenTg(const char* strLitModel, unsigned int maxTimeSeconds, const char* strNetInterface);

int main(int argc, char* argv[])
{
    const char* shortOptions = "m:i:t:vh";
    const struct option longOptions[] = 
    {
        {"max-time", required_argument, nullptr, 't'},
        {"model", required_argument, nullptr, 'm'},
        {"interface", required_argument, nullptr, 'i'},
        {"version", no_argument, nullptr, 'v'},
        {"help", no_argument, nullptr, 'h'},
        {nullptr, 0, nullptr, 0}
    };

    std::string litModel;
    std::string dstNetInterface = "eth0";
    unsigned int maxTimeSeconds = 3600;
    bool showHelp = false;
    bool showVersion = false;

    int opt;
    while ((opt = getopt_long(argc, argv, shortOptions, longOptions, nullptr)) != -1) {
        switch (opt) {
            case 'm':
                litModel = optarg;
                break;
            case 'i':
                dstNetInterface = optarg;
                break;
            case 't':
                maxTimeSeconds = std::stoi(optarg);
                break;
            case 'v':
                showVersion = true;
                break;
            case 'h':
                showHelp = true;
                break;
            case '?':
                break;  // Unrecognized option, handled by getopt
        }
    }

    if (showHelp) 
    {
        displayHelp();
        return 0;
    }

    if (showVersion) {
        
        displayVersion();
        return 0;
    }

    if(!litgenTg(litModel.c_str(), maxTimeSeconds, dstNetInterface.c_str()))
    {
        return -1;
    }

    return 0;
}

void displayHelp()
{
    printf("%s\n", helpMenu);
}

void displayVersion()
{
    std::cout << "litgen-tg version " << LITGEN_TG_VERSION << std::endl;
}

bool litgenTg(const char* strLitModel, unsigned int maxTimeSeconds, const char* strNetInterface)
{
    Timer timer;
    timer.init();

    LitModel model;
    LitModel::LoadResult res = model.load(strLitModel);
    if (res != LitModel::LoadResult::OK) 
    {
        printf("Error: Failed to load LitModel from %s\n", strLitModel);
        if (res == LitModel::LoadResult::FILE_NOT_FOUND)
        {
            printf("Error: file %s could not be found\n", strLitModel);
        }
        else if (res == LitModel::LoadResult::UNKNOWN_ERROR)
        {
            printf("Error: Unknown error.\n");
        }
        else if (res == LitModel::LoadResult::WRONG_FORMAT)
        {
            printf("Error: Wrong format.\n");
        }   

        return false;
    }

    TgEngine* engine = nullptr;

    if (StringUtils::endsWith(strNetInterface, ".csv")) 
    {
        engine = new TgCsv();
    } else if (StringUtils::endsWith(strNetInterface, ".pcap")) 
    {
        engine = new TgPcap();
    } else if (std::string(strNetInterface) == "console" || std::string(strNetInterface) == "stdout") 
    {
        engine = new TgConsole();
    } 
    else 
    {
        engine = new TgTins();
    }

    if (!engine) 
    {
        printf("Error: Failed to create traffic generator engine\n");
        return false;
    }

    printf("Modelling packets using litgen models %s...\n", strLitModel);
    engine->createSamples(model, static_cast<double>(maxTimeSeconds));
    printf("Elapsed time: %s seconds.\n", timer.elapsedTime().c_str());
    printf("Done\n");

    printf("Starting traffic generation at %s...\n", strNetInterface);
    engine->generate(strNetInterface);
    printf("All Done!\n");
    printf("Elapsed time: %s hh:mm:ss.\n", timer.elapsedTime().c_str());

    delete engine;
    return true;
}